import groovy.io.FileType
import org.gradle.util.VersionNumber

plugins {
    id "base"
    id "maven-publish"
    id "com.gradle.build-scan" version "2.3"
}

def groovyVersion = getProperty("groovyVersion")
def gradleGroovyAllVersion = getProperty("gradleGroovyAllVersion")

def release = hasProperty("release")
def snapshot = groovyVersion.endsWith("-SNAPSHOT")

group = "org.gradle.groovy"
version = "$gradleGroovyAllVersion-$groovyVersion"
description "Replacement for groovy-all.jar discontinued in Groovy 2.5"

println "The version is: $version"

buildScan {
    server = "https://e.grdev.net"
    publishAlways()
    value("RELEASED_VERSION", version)
}

allprojects {
    repositories {
        mavenCentral()
        maven { url = "https://oss.jfrog.org/artifactory/oss-snapshot-local" }
    }
}

configurations {
    groovy
    groovySources
    groovyJavadoc
    groovyGroovydoc
}

dependencies {
    groovy group: "org.codehaus.groovy", name: "groovy-all", version: groovyVersion
    if (VersionNumber.parse(groovyVersion) >= VersionNumber.parse("2.5.0")) {
        groovy group: "org.codehaus.groovy", name: "groovy-dateutil", version: groovyVersion
    }
}

task writeVersionProperties {
    def outputFile = file("${buildDir}/tmp/gradle-groovy-all-version.properties")
    inputs.property "version", version
    outputs.file outputFile
    doLast {
        outputFile.text = "version = $version\n"
    }
}

task configureGroovyAll {
    inputs.files writeVersionProperties.outputs
    inputs.files configurations.groovy

    doFirst {
        def toMerge = [
            'LICENSE'                       : 'META-INF/LICENSE',
            'NOTICE'                        : 'META-INF/NOTICE',
            'AST_TRANSFORMATION'            : 'META-INF/services/org.codehaus.groovy.transform.ASTTransformation',
            'EXTENSION_MODULE'              : 'META-INF/groovy/org.codehaus.groovy.runtime.ExtensionModule',
            'GROOVY_RELEASE_INFO_PROPERTIES': 'META-INF/groovy-release-info.properties',
            'GROOVY_RUNNER'                 : 'META-INF/services/org.apache.groovy.plugin.GroovyRunner',
            'INDEX_LIST'                    : 'META-INF/INDEX.LIST',
            'MANIFEST_MF'                   : 'META-INF/MANIFEST.MF'
        ]

        def collectDuplicates = { File[] roots ->
            Map<String, List<File>> duplicates = [:].withDefault { [] }
            roots.each { root ->
                root.eachFileRecurse(FileType.FILES) {
                    def relative = root.toURI().relativize(it.toURI())
                    duplicates[relative.toString()] += it
                }
            }
            return duplicates.findAll { it.value.size() > 1 }
        }

        def merge = { String relative, List<File> files ->
            switch (relative) {
                case [toMerge.LICENSE, toMerge.NOTICE, toMerge.AST_TRANSFORMATION]:
                    return files*.text.join("\n")
                case [toMerge.GROOVY_RELEASE_INFO_PROPERTIES]:
                    return files[0].text
                case toMerge.EXTENSION_MODULE:
                    return """
                        moduleName=groovy-all
                        moduleVersion=${(files[0].text =~ /moduleVersion=(.+)/)[0][1]}
                        extensionClasses=${(files*.text.join('\n') =~ /extensionClasses=(.+)/)*.getAt(1).toSet().join(',')}
                        staticExtensionClasses=${(files*.text.join('\n') =~ /staticExtensionClasses=(.+)/)*.getAt(1).toSet().join(',')}
                    """.stripIndent().trim()
                case [toMerge.MANIFEST_MF, toMerge.INDEX_LIST, toMerge.GROOVY_RUNNER]:
                    return null
                default:
                    throw new IllegalThreadStateException(files.toString())
            }
        }

        tasks.groovyAll {
            from writeVersionProperties

            configurations.groovy
                .filter { it.name ==~ /groovy-.*\.jar/ }
                .collect { zipTree(it) }
                .each { tree ->
                    tree.files /* extract archives */

                    def expandedArchives = new File("${buildDir}/tmp/expandedArchives")
                    def mergedFolder = new File(expandedArchives, 'merged')
                    collectDuplicates(expandedArchives.listFiles())
                        .each { String relative, List<File> files ->
                            def mergedFile = new File(mergedFolder, relative)
                            def content = merge(relative, files)
                            if (content != null) {
                                mergedFile.parentFile.mkdirs()
                                mergedFile.text = content
                            }
                        }

                    from(mergedFolder)
                    from(tree) { exclude toMerge.values() }
                }
        }
    }
}

task groovyAll(type: Jar) {
    dependsOn configureGroovyAll
    duplicatesStrategy = DuplicatesStrategy.FAIL
    archiveBaseName = "groovy-all"
    destinationDirectory = file("build/artifacts/jar")
}

task download {
    inputs.files configurations.groovy
    outputs.dir "${buildDir}/artifacts"
    doLast {
        ArtifactResolutionResult result = dependencies.createArtifactResolutionQuery()
            .forModule("org.codehaus.groovy", "groovy-all", groovyVersion)
            .withArtifacts(JvmLibrary, SourcesArtifact, JavadocArtifact)
            .execute()
        result.resolvedComponents.each { ComponentArtifactsResult component ->
            component.getArtifacts(SourcesArtifact).each { artifact ->
                copy {
                    from artifact.file
                    into "${buildDir}/artifacts/sources"
                }
            }
            component.getArtifacts(JavadocArtifact).each { artifact ->
                copy {
                    from artifact.file
                    into "${buildDir}/artifacts/javadoc"
                }
            }
        }
    }
}

task version {
    doLast {
        println version
    }
}

def jarArtifact = artifacts.add("default", groovyAll)
def sourcesArtifact = artifacts.add("default", file("${buildDir}/artifacts/sources/groovy-all-${groovyVersion}-sources.jar")) {
    builtBy download
    classifier "sources"
}
def javadocArtifact = artifacts.add("default", file("${buildDir}/artifacts/javadoc/groovy-all-${groovyVersion}-javadoc.jar")) {
    builtBy download
    classifier "javadoc"
}

publishing {
    publications {
        maven(MavenPublication) {
            artifact jarArtifact
            artifact sourcesArtifact
            artifact javadocArtifact
        }
    }
    repositories {
        maven {
            name = "local"
            url = "$buildDir/repos/external"
        }
        if (release) {
            maven {
                name = "gradle"
                def repoType = snapshot ? "snapshots" : "releases"
                url = "https://repo.gradle.org/gradle/ext-$repoType-local"
                authentication {
                    basic(BasicAuthentication) {
                        credentials {
                            username = property("artifactoryUser") ?: "nouser"
                            password = property("artifactoryPassword") ?: "nopass"
                        }
                    }
                }
            }
        }
    }
}
